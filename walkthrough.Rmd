Intro
===

This file contains all of the code used to create the presentation. I've ommitted the .pdf file generation used in the actual presentation so that you don't accidentally overwrite the original plots. By default, if you execute a code block below that creates a plot (typically, it will end with a single `p` command to print a `ggplot` object), it will simply appear in a pop-up R graphics device.

Libraries
===

  To run the code below, you need to install and load these libraries. If you don't have them installed, simply uncomment the `install.packages()` lines and run them. You only need to do that once, however you need to run the `library()` commands each time you start a new R session.

```{r}
# install all of the following if you don't have them
# you may have to install gdal to use the rgdal package
install.packages("ggmap")
install.packages("maps")
install.packages("geosphere")
install.packages("rgdal")
install.packages("maptools")
install.packages("ggplot2")
install.packages("plyr")

library(ggmap)
library(maps)
library(geosphere)
library(rgdal)
library(maptools)
library(ggplot2)
library(plyr)
```

Using R with geo-spatial data!
===

This simply demonstrates how to obtain lat/lon coordinates via Google Maps using `geocode()` from the `ggmaps` package:

```{r}
geocode("St. Paul, MN")

geocode("2115 Summit Ave., St. Paul, MN")

geocode("University of St. Thomas, MN")
```

Here we're using a lat/lon coordinate as the center of a map we're grabbing from Google using the `get_map()` function.

```{r}
# gets the coordinate
loc <- geocode("2115 Summit Ave, St. Paul, MN")

# gets a map centered on that coordinate with zoom=15
ust <- get_map(location = c(lon = loc$lon, lat = loc$lat),
                zoom = 15, source = "google",
                maptype = "hybrid", crop = T)

# plots the map we grabbed
ggmap(ust)
```

Alternately, if you don't want a square (which is what a center and zoom level get you), you can specify an actual bounding box via min/max values for lat and lon:

```{r}
# get a lat/lon
loc <- geocode("2115 Summit Ave, St. Paul, MN")

# here we can calculate how big the box should be
# we set our box to lon +/- 0.04 and lat +/- 0.02
box <- c(left = loc$lon - 0.04, bottom = loc$lat - 0.02,
         right = loc$lon + 0.04, top = loc$lat + 0.02)

# now we don't need to specify a zoom; just the box
# also note that we're grabbing from stamen maps this time
# and using the watercolor type
ust_box <- get_map(location = box, source = "stamen",
                   maptype = "watercolor", crop = T)

# plot the map
ggmap(ust_box)
```

#
locs <- data.frame(names = c("st. paul", "minneapolis"))
locs <- cbind(locs, geocode(as.character(locs$names)))

mid <- get_map(location = c(lon = mean(locs$lon), lat = mean(locs$lat)),
               zoom = 10, source = "stamen", maptype = "toner", crop = T)

p <- ggmap(mid)
p <- p + geom_point(aes(x = lon, y = lat, colour = factor(names)),
                    dat = locs, size = 6)
p <- p + scale_colour_discrete("Location")
p
},error=function(e){plot(x=-1:1, y=-1:1, type='n', xlab='', ylab='', axes=FALSE); text(x=0, y=0, labels=e$message, col='red'); paste('ERROR', e$message, sep=' : ')}); dev.off()

library(maps)
world <- map_data("world")
head(map, 5)

pdf(file="./img/world.pdf",height=6,width=9); tryCatch({
# pay attention to column names (lon vs. long!)
p <- ggplot(world, aes(x = long, y = lat, group = group))
p <- p + geom_polygon(colour = "white")
p
},error=function(e){plot(x=-1:1, y=-1:1, type='n', xlab='', ylab='', axes=FALSE); text(x=0, y=0, labels=e$message, col='red'); paste('ERROR', e$message, sep=' : ')}); dev.off()

pdf(file="./img/usa.pdf",height=6,width=9); tryCatch({
usa <- map_data("state")
p <- ggplot(usa, aes(x = long, y = lat, group = group))
p <- p + geom_polygon(colour = "white")
p
},error=function(e){plot(x=-1:1, y=-1:1, type='n', xlab='', ylab='', axes=FALSE); text(x=0, y=0, labels=e$message, col='red'); paste('ERROR', e$message, sep=' : ')}); dev.off()

pdf(file="./img/some-states.pdf",height=6,width=6); tryCatch({
states <- c("minnesota", "wisconsin", "illinois", "indiana",
            "iowa", "missouri", "michigan")

states_map <- map_data("state")

states_map <- states_map[states_map$region %in% states, ]

p <- ggplot(states_map, aes(x = long, y = lat, group = group))
p <- p + geom_polygon(colour = "white")
p
},error=function(e){plot(x=-1:1, y=-1:1, type='n', xlab='', ylab='', axes=FALSE); text(x=0, y=0, labels=e$message, col='red'); paste('ERROR', e$message, sep=' : ')}); dev.off()

library(geosphere)
arc <- gcIntermediate(c(lon_1, lat_1), c(lon_2, lat_2),
                      n = steps, addStartEnd = T)

# draw great circles from St. Paul to everywhere else
gcircles <- lapply(1:nrow(end), function(i) {
  temp <- gcIntermediate(start[, c("lon", "lat")], end[i, c("lon", "lat")],
                         n = 50, addStartEnd = T, breakAtDateLine = T)

  # if temp is a list, rbind and return single data.frame
  if(is.list(temp) == T) {
    ids <- c(rep(paste0("i", i), nrow(temp[[1]])),
             rep(paste0("j", i), nrow(temp[[2]])))
    temp <- as.data.frame(rbind(temp[[1]], temp[[2]]))
    temp$id <- ids
  }
  
  ...
})

p <- ggplot()
p <- p + geom_polygon(aes(x = long, y = lat, group = group),               # world map
                      data = world, colour = "gray10", fill = "gray95")
p <- p + geom_line(aes(x = lon, y = lat, group = id),                      # great circles
                   dat = gcircles, lwd = 0.4, alpha = 0.5)
p <- p + geom_point(aes(x = lon, y = lat, size = sqrt(total/pi)),          # points
                    dat = talks_agg, colour = "#555599")
p <- p + scale_size("Total participants\n(both events)",                   # adjust legend
                    limits = c(0, max(sqrt(talks_agg$total / pi)) + 1),
                    breaks = sqrt(c(10, 50, 100) / pi),
                    labels = c(10, 50, 100), range = c(1, 10))
p <- p + theme_bw()                                                        # bw theme
p <- p + theme(axis.text = element_blank(), axis.title = element_blank(),  # tweak
               axis.ticks = element_blank(), panel.grid = element_blank(),
               legend.position = c(0.092, 0.15))

pdf(file="./img/great-circles.pdf",height=7,width=13); tryCatch({

talks <- read.csv("./data/talk-locations.csv")
head(talks, 5)

talks$total <- talks$live + talks$rec
talks_agg <- ddply(talks, .(country, city), summarize,
                   total = sum(total), lat = lat[1], lon = lon[1])

start <- talks_agg[talks_agg$city == "Saint Paul", ]
end <- talks_agg[talks_agg$city != "Saint Paul", ]

# draw great circles from St. Paul to everywhere else
gcircles <- lapply(1:nrow(end), function(i) {
  temp <- gcIntermediate(start[, c("lon", "lat")], end[i, c("lon", "lat")],
                         n = 50, addStartEnd = T, breakAtDateLine = T)

  # if temp is a list, rbind and return single list
  if(is.list(temp) == T) {
    ids <- c(rep(paste0("i", i), nrow(temp[[1]])),
             rep(paste0("j", i), nrow(temp[[2]])))
    temp <- as.data.frame(rbind(temp[[1]], temp[[2]]))
    temp$id <- ids
  }

  else {
    ids <- rep(paste0("i", i), nrow(temp))
    temp <- as.data.frame(temp)
    temp$id <- ids
  }
  
  return(temp)
  
})

gcircles <- do.call(rbind, gcircles)

world <- map_data("world")
world <- world[world$lat > -57, ]

# initialize a ggplot object; need to do it this way since
# we're using independent layers that don't share same aes params
p <- ggplot()

# plot the world map
p <- p + geom_polygon(aes(x = long, y = lat, group = group),
                      data = world, colour = "gray10",
                      fill = "gray95")

# plot the great circles
p <- p + geom_line(aes(x = lon, y = lat, group = id),
                   dat = gcircles, lwd = 0.4, alpha = 0.5)

# plot points, sized by area
p <- p + geom_point(aes(x = lon, y = lat,
                    size = sqrt(total/pi)), dat = talks_agg,
                    colour = "#555599")

# set label for legend; rescale sizes/lagels for area vs. diameter
p <- p + scale_size("Total participants\n(both events)",
                    limits = c(0, max(sqrt(talks_agg$total / pi)) + 1),
                    breaks = sqrt(c(10, 50, 100) / pi),
                    labels = c(10, 50, 100), range = c(1, 10))
p <- p + theme_bw()

# gets rid of axis text/ticks, moves legend to lower left vs. right side
p <- p + theme(axis.text = element_blank(),
               axis.title = element_blank(),
               axis.ticks = element_blank(),
               panel.grid = element_blank(),
               legend.position = c(0.092, 0.15))

p
},error=function(e){plot(x=-1:1, y=-1:1, type='n', xlab='', ylab='', axes=FALSE); text(x=0, y=0, labels=e$message, col='red'); paste('ERROR', e$message, sep=' : ')}); dev.off()

# create spatial projection object from data
talks_agg$size <- 100 * talks_agg$total

talks_sp <- talks_agg
coordinates(talks_sp) <- c("lon", "lat")
proj4string(talks_sp) <- CRS("+init=epsg:4238")
talks_ll <- spTransform(talks_sp,
                        CRS("+proj=longlat +datum=WGS84"))

kml_open("./data/talks-w-gcircles.kml")
kml_layer.SpatialPoints(talks_ll, colour = "white", labels = city, size = total,
                        shape="http://upload.wikimedia.org/wikipedia/commons/a/af/Tux.png")
kml_close("./data/talks-w-gcircles.kml")

# a bit hackish, but manually writing the kml code works, too!
gcircs <- lapply(1:nrow(end), function(i) {
  paste0("<Placemark><LineString><tesselate>1</tesselate><coordinates>",
         start$lon, ",", start$lat, " ", end[i, "lon"], ",", end[i, "lat"],
         "</coordinates></LineString></Placemark>") })

gcircs <- do.call(rbind, gcircs)

# paste this after last <coordinate> in .kml file
write.table(gcircs, row.names = F)

talks_agg$size <- 10 * (sqrt(talks_agg$total)/pi)

talks_sp <- talks_agg
coordinates(talks_sp) <- c("lon", "lat")
proj4string(talks_sp) <- CRS("+init=epsg:4238")
talks_ll <- spTransform(talks_sp,
                        CRS("+proj=longlat +datum=WGS84"))

kmlPoints(talks_ll["city"], kmlfile = "./data/talks-google-earth.kml",
          name = talks_ll$city,
          icon = "http://upload.wikimedia.org/wikipedia/commons/a/af/Tux.png")

pdf(file="./img/gps-map.pdf",height=4,width=9); tryCatch({
box <- c(left = min(gps$lon), bottom = min(gps$lat),
         right = max(gps$lon), top = max(gps$lat))

gps_map <- get_map(location = box, source = "stamen",
                   maptype = "terrain", crop = T)
},error=function(e){plot(x=-1:1, y=-1:1, type='n', xlab='', ylab='', axes=FALSE); text(x=0, y=0, labels=e$message, col='red'); paste('ERROR', e$message, sep=' : ')}); dev.off()

pdf(file="./img/gps-map-over.pdf",height=5,width=12); tryCatch({
p <- ggmap(gps_map) + geom_point(aes(x = lon, y = lat, colour = speed),
                                 data = gps, size = 3)
p <- p + scale_colour_continuous(low = "black", high = "red", na.value = NA)
},error=function(e){plot(x=-1:1, y=-1:1, type='n', xlab='', ylab='', axes=FALSE); text(x=0, y=0, labels=e$message, col='red'); paste('ERROR', e$message, sep=' : ')}); dev.off()

transpo <- read.csv("./data/public-transpo.csv")

transpo_agg <- ddply(transpo, .(city, state), summarize,
                     btus_pmile_ave = mean(btus_pmile),
                     density = mean(population) / mean(service_area_sq_mi))
transpo_agg$lookup <- paste0(transpo_agg$city, ", ", transpo_agg$state)

coords <- geocode(transpo_agg$lookup)

transpo_agg <- cbind(transpo_agg, coords)

# let's not run that again...
write.table(transpo_agg, file = "./data/transpo-agg-geocoded.csv", row.names = F, sep = ",")

pdf(file="./img/transpo-plot.pdf",height=6,width=11); tryCatch({
plot <- read.csv("./data/transpo-agg-geocoded.csv")
plot <- plot[plot$state != "AK" & plot$state != "HI", ]
usa <- map_data("state")
plot <- plot[order(plot$btus_pmile_ave), ]
p <- ggplot() + geom_polygon(aes(x = long, y = lat, group = group),
                             data = usa, fill = "gray95", colour = "gray10")
p <- p + geom_point(aes(x = lon, y = lat, colour = btus_pmile_ave,
                    size = sqrt(density)/pi), data = plot)
p <- p + scale_colour_gradient("BTUs / passenger-mile", trans = "log")
p <- p + scale_x_continuous("") + scale_y_continuous("")
p <- p + scale_size_continuous("Passengers / Sq. Mile", breaks = c(10, 20, 30, 40),
                               labels = round((c(10, 20, 30, 40)*pi)^2, 0),
                               range = c(1, 8))
p <- p + theme_bw() + theme(axis.text = element_blank(), axis.ticks = element_blank())
},error=function(e){plot(x=-1:1, y=-1:1, type='n', xlab='', ylab='', axes=FALSE); text(x=0, y=0, labels=e$message, col='red'); paste('ERROR', e$message, sep=' : ')}); dev.off()

plot_json <- toJSONarray(plot)
file_con <- file("./d3/transpo.json")
writeLines(plot_json, file_con)
close(file_con)
